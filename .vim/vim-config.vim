" Use this to make loading minified files tolerable
function! BufferTextExceedsLimit() abort
  if exists('$VIM_VERY_FAST')
    return 1
  endif
  if exists('b:is_minified_file')
    return b:is_minified_file
  endif
  let lines = getline(1, '$')
  for line in lines
    if len(line) > 1000
      return 1
    endif
  endfor
  return 0
endfunction
augroup minifiedCheck
  autocmd!
  autocmd BufNewFile,BufReadPost,FileType * let b:is_minified_file = BufferTextExceedsLimit()
        \| if b:is_minified_file | syntax off | endif
augroup END

" ---------------------------------------- Main layout
set shiftwidth=2
set softtabstop=2
set tabstop=2

set number
set expandtab
" help foldtext, disable and `set fillchars?` to see default
set fillchars=vert:\|
set mouse=a
set cursorline
hi CursorLine   cterm=bold,underline ctermbg=NONE ctermfg=NONE guibg=blue guifg=orange "Set cursor line highlight colours
set splitright splitbelow
set scrolloff=1
set smartindent
if !has('nvim')
  set lazyredraw "perf
endif
set nobackup " swap files are relatively pointless
set noswapfile " swap files are relatively pointless
set tabpagemax=100 "normally 10
set relativenumber
set autoread "detect if file has changed
set display+=lastline "long lines show to the end instead of @ sign
set complete+=kspell " autocomplete includes the dictionary if enabled
"set synmaxcol=1000 " Stop trying to syntax highlight after synmaxcol characters. Vim is very slow with syntax highlighting long lines

" git and lsp use these stop the movement
set signcolumn=yes
set foldmethod=syntax
set foldlevel=20

set updatetime=1000 "event when cursor stops moving for a second, for swp normally, but now is for checktime call below
" Ignore case except when there atleast one capital, use \C for case sensitive
" Position of \c / \C is irrelevant
set ignorecase
set smartcase

" Always report the number of lines changed by a command
set report=0

" Sentances that end in period join with 1 space, not two
set nojoinspaces

" Default to 99 so that `gq` wraps at 100
"set textwidth=99

" Display as much as possible of cut off lines rather than truncating
"set display=lastline

" Don't automatically add eol characters, e.g. for autogenerated files
set nofixeol

" https://stackoverflow.com/questions/26708822/why-do-vim-experts-prefer-buffers-over-tabs
set hidden " can switch to another buffer when you have unsaved changes

" default is jtcroql, see help fo-table
" set -= only supports one character at a time
" o: don't auto insert comments on "o", t: don't auto wrap, n: recognise lists
" Autocmd cause ftplugins set it too
augroup formatOptions
  autocmd!
  autocmd FileType * set formatoptions-=t
  autocmd FileType * set formatoptions-=o
  autocmd FileType * set formatoptions+=n
augroup END

" Tab completion, as much as possible, list options, then tab through each option
"set wildmode=longest,list,full
"set wildmenu

" Maintain undo history between sessions
" https://jovicailic.org/2017/04/vim-persistent-undo/
" https://stackoverflow.com/questions/1549263/how-can-i-create-a-folder-if-it-doesnt-exist-from-vimrc
if has('nvim')
  if !isdirectory($HOME.'/.vim/nundodir')
    call mkdir($HOME.'/.vim/nundodir', 'p')
  endif
  set undodir=~/.vim/nundodir
else
  if !isdirectory($HOME.'/.vim/undodir')
    call mkdir($HOME.'/.vim/undodir', 'p')
  endif
  set undodir=~/.vim/undodir
endif
set undofile

" Set spelling settings, use ]s [s for next previous spelling error, zg to add
" to spellfile, z= to see similar words
" Includes all the regions such as en_us en_nz
set spelllang=en
set spellfile=~/.spellfile.utf-8.add
" set spellsuggest=double " if you want to use a super slow but phoentic
" version v normal just edit distance

" Encryption method, defaults to super weak
"set cryptmethod=blowfish2

" Project vimrcs: https://andrew.stwrt.ca/posts/project-specific-vimrc/
set exrc

" Add characters for tabs and spaces on the end of lines
if &listchars ==# 'eol:$'
  set listchars=tab:>\ ,trail:·,extends:>,precedes:<,nbsp:+
endif
set list

if !has('nvim')
  set incsearch
  set autoindent
  set hlsearch
  set ruler
  set showcmd
  set laststatus=2 " Always show a status bar
  set backspace=indent,eol,start "Without this, you can't backspace an indent or line
  set synmaxcol=1000 " Stop trying to syntax highlight after synmaxcol characters. Vim is very slow with syntax highlighting long lines
  set nocompatible " fancy vim features
  " Do not move the cursor to the first non-blank when jumping (ctrl-d etc)
  set nostartofline

  " Display as much as possible of cut off lines rather than truncating
  set display=lastline

  " Tab completion, as much as possible, list options, then tab through each option
  set wildmode=longest,list,full
  set wildmenu

  " Encryption method, defaults to super weak
  set cryptmethod=blowfish2

  " Turns off the bell (audible)
  set visualbell t_vb=
  " sets default font to what is in macos terminal
  set guifont=Monaco:h13
  " No blinking cursor
  set guicursor+=a:blinkon0
  " Randomly pulled from https://github.com/lifepillar/vim-solarized8/issues/45
  " cause defaults aren't good
  let g:terminal_ansi_colors = ['#073642', '#dc322f', '#859900', '#b58900', '#268bd2', '#d33682', '#2aa198', '#eee8d5',
        \ '#002b36', '#cb4b16', '#93a1a1', '#839496', '#657b83', '#6c71c4', '#586e75', '#fdf6e3']

  " https://stackoverflow.com/questions/25233859/vimdiff-immediately-becomes-stopped-job-crashes-terminal-when-i-try-to-fg-it-b
  " set shell=/bin/zsh\ -l
  " Why do I want this?
  if &diff ==# 'nodiff'
      "set shellcmdflag=-ic
  endif

  "enable's syntax highlighting, corrollary: https://stackoverflow.com/questions/33380451/is-there-a-difference-between-syntax-on-and-syntax-enable-in-vimscript
  syntax enable

  " https://vi.stackexchange.com/questions/10124/what-is-the-difference-between-filetype-plugin-indent-on-and-filetype-indent
  " filetype - detection - detect type of syntax by filetype
  " plugin - allow plugins (not sure this is necessary as we use vim-plug)
  " indent - indent file helps with indenting
  filetype plugin indent on
else
  " Neovim issue: https://github.com/neovim/neovim/wiki/FAQ#calling-inputlist-echomsg--in-filetype-plugins-and-autocmd-does-not-work
  set shortmess-=F
endif

" Turns off the bell (audible)
"set visualbell t_vb=
" sets default font to what is in macos terminal
"set guifont=Monaco:h12
" No blinking cursor
"set guicursor+=a:blinkon0
" Randomly pulled from https://github.com/lifepillar/vim-solarized8/issues/45
" cause defaults aren't good
"let g:terminal_ansi_colors = ['#073642', '#dc322f', '#859900', '#b58900', '#268bd2', '#d33682', '#2aa198', '#eee8d5',
"      \ '#002b36', '#cb4b16', '#93a1a1', '#839496', '#657b83', '#6c71c4', '#586e75', '#fdf6e3']

let mapleader=' '

" ---------------------------------------- netrw

" netrw is kinda a plugin? Makes it a tree FYI
" https://shapeshed.com/vim-netrw/#nerdtree-like-setup
" Probably can remove vim-vinegar in favour of personalised setup
let g:netrw_liststyle = 3
let g:netrw_banner = 0
"let g:netrw_browse_split = 4
let g:netrw_winsize = 25
let g:netrw_preview = 1
"let g:netrw_altv = 1
let g:netrw_alto = 0
nnoremap <silent> - :call OpenNetrw()<cr>
"nnoremap - :Ex<cr>
function! OpenNetrw()
  let file = '\V'.expand('%:t')
  execute 'Ex'
  call search(file)
endfunction
autocmd FileType netrw nnoremap <buffer> P <c-w>z
" https://vi.stackexchange.com/questions/14622/how-can-i-close-the-netrw-buffer
autocmd FileType netrw setl bufhidden=wipe
"let g:netrw_fastbrowse = 0
autocmd FileType netrw nmap <buffer> h -
autocmd FileType netrw nmap <buffer> l gn
autocmd FileType netrw nmap <buffer> v i:Vifm<cr>

" ---------------------------------------- Mappings
" set spell spelllang=en_nz " ]s [s ]S [S " next spelling error
nnoremap <Leader>sp :setl spell!<CR>

" Show help we defined above
nnoremap <leader>? :call ShowPersonalHelp()<cr>

imap jj <Esc>l
imap jk <Esc>l

" movement in insert mode is nice to have
imap <c-l> <right>
imap <c-h> <left>
imap <c-j> <down>
imap <c-k> <up>

" https://stackoverflow.com/questions/15808767/vimrc-to-detect-remote-connection
let g:localSession = ($SSH_CLIENT == "")

" HOC for calling system with interactive flags which have the shell rc files
function Isystem(a, ...)
  if !g:localSession
    set shellcmdflag=-ic
  endif
  let l:res = ""

  if a:0 == 1
    let l:res = system(a:a, a:1)
  else
    let l:res = system(a:a)
  endif
  if !g:localSession
    set shellcmdflag=-c
  endif
  return l:res
endfunction

" copy and pasting
vnoremap <C-c> y:call Isystem("pbcopy", getreg('"'))<CR>
nnoremap <C-v><C-v> :call setreg("\"", Isystem("pbpaste"))<CR>p

" Highlight rows and columns with \l and \c, 'l to move, :match to remove
" highlighting
"nnoremap <silent> <Leader>l ml:execute 'match Search /\%'.line('.').'l/'<CR>
"nnoremap <silent> <Leader>c :execute 'match Search /\%'.virtcol('.').'v/'<CR>

"Tab mappings
" tab navigation like firefox
nnoremap <silent> {         :tabprevious<CR>
nnoremap <silent> }         :tabnext<CR>
"nnoremap <C-t>     :tabnew<CR>
"inoremap <C-{>     <Esc>:tabprevious<CR>
"inoremap <C-}>     <Esc>:tabnext<CR>
"inoremap <C-t>     <Esc>:tabnew<CR>
nnoremap <silent> (         :tabmove -1<cr>
nnoremap <silent> )         :tabmove +1<cr>

" Window mappings (use alt hjkl)
nnoremap <silent> ˙ <C-w>h
nnoremap <silent> ∆ <C-w>j
nnoremap <silent> ˚ <C-w>k
nnoremap <silent> ¬ <C-w>l
" inoremap <silent> ˙ <esc><C-w>h
" inoremap <silent> ∆ <esc><C-w>j
" inoremap <silent> ˚ <esc><C-w>k
" inoremap <silent> ¬ <esc><C-w>l
nnoremap <silent> Ó :vertical resize -5<cr>
nnoremap <silent> Ô :resize +5<cr>
" This is wrong but Shift-Alt-K doesn't seem to work? Uses I instead
nnoremap <silent> ˆ :resize -5<cr>
nnoremap <silent> Ò :vertical resize +5<cr>

" Incrementing and decrementing visual blocks
" https://stackoverflow.com/questions/23481635/how-to-use-vims-normal-mode-ctrl-a-number-increment-in-visual-block-mode
xnoremap <C-a> :<C-u>let vcount = v:count ? v:count : 1 <bar> '<,'>s/\%V\d\+/\=submatch(0) + vcount <cr>gv
xnoremap <C-x> :<C-u>let vcount = v:count ? v:count : 1 <bar> '<,'>s/\%V\d\+/\=submatch(0) - vcount <cr>gv

" show errors if you want (need to work out how to show automatically)
nmap <c-l> :lwindow<cr>

" Scroll mappings
map <ScrollWheelUp> <C-Y>
map <ScrollWheelDown> <C-E>

" This is just annoying
noremap K k
"autocmd FileType c,cpp nunmap <buffer> K

" Disable smart indenting for these langauges
autocmd FileType yaml setl indentexpr=
autocmd FileType html setl indentexpr=
autocmd FileType make setl indentexpr=
autocmd FileType sh setl indentexpr=
autocmd FileType scala setl indentexpr=
autocmd FileType javascript setl indentexpr=
autocmd FileType typescript setl indentexpr=
autocmd FileType swift,objc,objcpp setl textwidth=0

" Handle special file types: https://vim.fandom.com/wiki/Forcing_Syntax_Coloring_for_files_with_odd_extensions
autocmd BufNewFile,BufRead *.keymap setl syntax=c
autocmd BufNewFile,BufRead tsconfig.json setl ft=jsonc
autocmd BufNewFile,BufRead coc-settings.json setl ft=jsonc


" nnoremap <C-L> :redraw!

" delete without yanking
"nnoremap d "_d
"vnoremap d "_d
" replace currently selected text with default register
" without yanking it
xnoremap p "_dP

" Moving cursor by display lines
" -  http://vim.wikia.com/wiki/Move_cursor_by_display_lines_when_wrapping
"noremap  <buffer> <silent> k gk
"noremap  <buffer> <silent> j gj
"noremap  <buffer> <silent> 0 g0
"noremap  <buffer> <silent> $ g$

" diffget for mergetool left and right is also local and remote
" 1do is equivalent to :diffget LO, 2do is equivalent to :diffget BA, etc.
if &diff
  " &diff = 1 in a vimdiff mergetool
  nnoremap dgl :diffget LOCAL<cr>
  nnoremap dgr :diffget REMOTE<cr>
  nnoremap dg1 :diffget 1<cr>
  nnoremap dg2 :diffget 2<cr>
  nnoremap dg3 :diffget 3<cr>
endif

" Yank current file path
nnoremap yp :let @" = expand("%:p")<CR>
nnoremap <silent> ygp :let @" = system('git ls-tree --name-only --full-name HEAD '.expand("%:p"))[:-2]<cr>
" ideally just get the last buffer
"nnoremap <silent> <leader>yr :call system("grealpath --relative-to=".@"." ".system('git ls-tree --name-only --full-name HEAD '.expand("%:p"))[:-2])<cr>
nnoremap <silent> ygr :call <SID>RelGitPath()<cr>
function! s:RelGitPath()
  let currGitPath = system('git ls-tree --name-only --full-name HEAD '.expand("%:p"))[:-2]
  let @" = system("grealpath --relative-to=\"$(dirname ".@".")\" ".currGitPath)[:-2]
endfunction
nnoremap <silent> ygo :call <SID>RelGitRevPath()<cr>
function! s:RelGitRevPath()
  let currGitPath = system('git ls-tree --name-only --full-name HEAD "'.expand("%:p").'"')[:-2]
  let @" = system("grealpath --relative-to=\"$(dirname ".currGitPath.")\" \"".@"."\"")[:-2]
endfunction

" Insert single character
nnoremap s :exec "normal i".nr2char(getchar())."\el"<CR>
nnoremap S :exec "normal a".nr2char(getchar())."\el"<CR>

nnoremap ZS :w<cr>
" quit vim all
nnoremap ZE :wqa<cr>
nnoremap ZT :q<cr>
nnoremap ZX :qa<cr>
" quit vim with exit code
nnoremap ZC :cq<cr>
nnoremap ZV :qa!<cr>
nnoremap <Leader>ss :w<CR>
nnoremap <Leader>sh :wq<CR>
nnoremap <Leader>se :wq<CR>
nnoremap <Leader>sa :wqa<CR>
nnoremap <Leader>sn :wqa<CR>
nnoremap <Leader>st :q<CR>
nnoremap <Leader>sx :qa<CR>
nnoremap <Leader>sr :qa<CR>
nnoremap <Leader>sc :cq<CR>
nnoremap <Leader>sv :qa!<CR>

" https://stackoverflow.com/questions/40289706/execute-selection-from-script-in-vim
"autocmd FileType rust xnoremap <buffer> <leader>e :w !echo 'fn main() {' "$(cat)" '}' > __temp.rs && cargo script __temp.rs; \rm __temp.rs<cr>
"autocmd FileType rust xnoremap <buffer> <leader><leader>e :w !echo "$(cat)" > __temp.rs && cargo script __temp.rs; \rm __temp.rs<cr>

" ---------------------------------------- Allow undo in insert mode
inoremap <c-u> <esc>ua
" https://vi.stackexchange.com/questions/16773/how-to-undo-the-deletion-of-characters-in-insert-mode-caused-by-ctrl-u
" Break on cr so that you can undo an enter with indenting
inoremap <cr> <c-g>u<cr>

" --------------- from https://sanctum.geek.nz/arabesque/vim-annoyances/
" always middle on next, needs to be remaped as per plugin FYI, see below
" (anzu), but the zz removes the anzu output so this does nothing for now
nnoremap N Nzz
nnoremap n nzz

" Disable Ex mode on Q
nnoremap Q <nop>
"nnoremap K <nop> " already remaped elsewhere

" ---------------------------------------- Reload page on change
" https://stackoverflow.com/questions/923737/detect-file-change-offer-to-reload-file
"au CursorHold * checktime
"After with https://vi.stackexchange.com/questions/14315/how-can-i-tell-if-im-in-the-command-window
"autocmd FocusGained,BufEnter,CursorHold,CursorHoldI * if !bufexists("[Command Line]") | checktime | endif
" This answer checks for command line correctly https://stackoverflow.com/a/26035664
au FocusGained,BufEnter,CursorHold,CursorHoldI * if getcmdwintype() == '' | checktime | endif

" ---------------------------------------- Functions and commands
" https://vim.fandom.com/wiki/Customize_text_for_closed_folds
" Set a nicer foldtext function
set foldtext=MyFoldText()
function! MyFoldText()
  let line = getline(v:foldstart)
  if match( line, '^[ \t]*\(\/\*\|\/\/\)[*/\\]*[ \t]*$' ) == 0
    let initial = substitute( line, '^\([ \t]\)*\(\/\*\|\/\/\)\(.*\)', '\1\2', '' )
    let linenum = v:foldstart + 1
    while linenum < v:foldend
      let line = getline( linenum )
      let comment_content = substitute( line, '^\([ \t\/\*]*\)\(.*\)$', '\2', 'g' )
      if comment_content !=# ''
        break
      endif
      let linenum = linenum + 1
    endwhile
    let sub = initial . ' ' . comment_content
  else
    let sub = line
    let startbrace = substitute( line, '^.*{[ \t]*$', '{', 'g')
    if startbrace ==# '{'
      let line = getline(v:foldend)
      let endbrace = substitute( line, '^[ \t]*}\(.*\)$', '}', 'g')
      if endbrace ==# '}'
        let sub = sub.substitute( line, '^[ \t]*}\(.*\)$', '...}\1', 'g')
      endif
    endif
  endif
  let n = v:foldend - v:foldstart + 1
  let info = ' ' . n . ' lines'
  let sub = sub . repeat(' ', winwidth(0))
  let num_w = getwinvar( 0, '&number' ) * getwinvar( 0, '&numberwidth' )
  let fold_w = getwinvar( 0, '&foldcolumn' )
  let sub = strpart( sub, 0, winwidth(0) - strlen( info ) - num_w - fold_w - 2 )

  return sub . info
endfunction
autocmd FileType vim setl foldexpr=GetLineFold(v:lnum)

" Inspiration: https://vi.stackexchange.com/questions/3814/is-there-a-best-practice-to-fold-a-vimrc-file
function! GetLineFold(lnum)
  if getline(a:lnum) =~? '\v^.*-{5}'
    return '>1'
  endif
  if getline(a:lnum) =~? '\v^.*[=]{3}'
    return '>0'
  endif
  if getline(a:lnum) =~? '\v^Plug'
    return '>1'
  endif
  return '='
endfunction

" For profiling:
function Prof()
  profile start profile.log
  profile func *
  profile file *
endfunction

function EndProf()
  profile pause
  noautocmd qall!
endfunction
command! Prof :call Prof()
command! EndProf :call EndProf()
" https://vi.stackexchange.com/questions/19337/is-there-a-way-to-tell-what-autocmds-have-run

" Delete current file:
command! DeleteFile :call delete(expand('%')) | bdelete!

" Strip file whitespace before saving
autocmd BufWritePre * :keeppatterns %s/\s\+$//e

if !has('nvim')
  " Switch to last buffer :b#

  "" Set cursor based on insert v normal mode
  let &t_SI = "\e[6 q"
  let &t_EI = "\e[2 q"
endif

"let &t_SI.="\e[5 q" "SI = INSERT mode
"let &t_SR.="\e[4 q" "SR = REPLACE mode
"let &t_EI.="\e[1 q" "EI = NORMAL mode (ELSE)

"Cursor settings:

"  1 -> blinking block
"  2 -> solid block
"  3 -> blinking underscore
"  4 -> solid underscore
"  5 -> blinking vertical bar
"  6 -> solid vertical bar

" optional reset cursor on start: #doesn't work with alfred
"augroup myCmds
"  autocmd!
"  autocmd VimEnter * silent !echo -ne "\e[2 q"
"augroup END

" Normally you can open a url with gx, doesnt work so use <leader>u
" Hint, can also open files with gf
function! HandleURL()
  let s:uri = matchstr(getline('.'), '[a-z]*:\/\/[^ >,;]*')
  echo s:uri
  if s:uri !=# ''
    silent exec "!open '".s:uri."'"
  else
    echo 'No URI found in line.'
  endif
  redraw!
endfunction
map <leader>u :call HandleURL()<cr>

" Restore cursor position horizontally when switching buffer
" Switching tabs this is weird??
"autocmd BufEnter * silent! normal! g`"

" A few personal aliases that make editing certain files easier
command Notes :n ~/Dropbox/Notes/Notes.md
\ ~/Dropbox/Notes/*.md
\ ~/Dropbox/Documents/twitter/*.md
\ ~/Dropbox/Documents/ambitus/*.md

nnoremap <leader>nn :Notes<cr>
nnoremap <leader>nd :tabe<cr>:lcd ~/ws/dotfiles<cr>:n ~/ws/dotfiles/.sharedrc.sh<cr>
nnoremap <leader>nv :tabe<cr>:lcd ~/ws/dotfiles<cr>:n .vimrc .vim/*.vim .config/nvim/*.vim .config/nvim/lua/*.lua<cr>
nnoremap <leader>ns :tabe<cr>:lcd ~/ws/deps/espanso/match<cr>:n twitter.yml *.yml<cr>

" clear auto commands with !au (if you want) and reload vim, can use RestartVim in MacVim?
command Reload :au! | so ~/.vimrc

" Close all except current buffer
" https://stackoverflow.com/questions/4545275/vim-close-all-buffers-but-this-one
command BufOnly :%bd|e#

" https://stackoverflow.com/questions/1534835/how-do-i-close-all-buffers-that-arent-shown-in-a-window-in-vim
function! DeleteInactiveBufs()
    "From tabpagebuflist() help, get a list of all buffers in all tabs
    let tablist = []
    for i in range(tabpagenr('$'))
        call extend(tablist, tabpagebuflist(i + 1))
    endfor

    "Below originally inspired by Hara Krishna Dara and Keith Roberts
    "http://tech.groups.yahoo.com/group/vim/message/56425
    let nWipeouts = 0
    for i in range(1, bufnr('$'))
        if bufexists(i) && !getbufvar(i,"&mod") && index(tablist, i) == -1
        "bufno exists AND isn't modified AND isn't in the list of buffers open in windows and tabs
            silent exec 'bwipeout' i
            let nWipeouts = nWipeouts + 1
        endif
    endfor
    echomsg nWipeouts . ' buffer(s) wiped out'
endfunction
command! Bdi :call DeleteInactiveBufs()

" Recreate tmpdir if deleted while sleeping
" https://github.com/neovim/neovim/pull/11284
" https://groups.google.com/g/vim_use/c/qgRob9SWDv8/m/FAOFVVcDTv0J
command! Mktmpdir call mkdir(fnamemodify(tempname(),":p:h"),"p",0700)
nnoremap <silent> <leader>mk :Mktmpdir<cr>
autocmd FocusGained,BufEnter,CursorHold,CursorHoldI,VimLeavePre * Mktmpdir

function! ErrorWrapMissing(func)
    try
        execute a:func
    catch /^Vim\%((\a\+)\)\=:E482/
        Mktmpdir
        execute a:func
    endtry
endfunction


" https://stackoverflow.com/questions/19430200/how-to-clear-vim-registers-effectively
function ClearReg()
  let regs=split('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789/-"', '\zs')
  for r in regs
    call setreg(r, [])
  endfor
endfunction
command! ClearReg :call ClearReg()

function! s:CopyGitPath() range
  execute 'silent !printf "\%s\#n' . a:firstline . '" "$(git ls-tree --name-only --full-name HEAD %)" | pbcopy'
  redraw!
endfunction
function! s:CopyPath() range
  execute 'silent !printf "\%s" "$(git ls-tree --name-only --full-name HEAD %)" | pbcopy'
  redraw!
endfunction

nnoremap <Leader>ygp :call <SID>CopyGitPath()<CR>
nnoremap <Leader>ycp :call <SID>CopyPath()<CR>

if !has('nvim')
  " Set pasting to automatically go paste mode
  " - https://coderwall.com/p/if9mda
  let &t_SI .= "\<Esc>[?2004h"
  let &t_EI .= "\<Esc>[?2004l"

  inoremap <special> <expr> <Esc>[200~ XTermPasteBegin()

  function! XTermPasteBegin()
    set pastetoggle=<Esc>[201~
    set paste
    return ''
  endfunction
endif

" ---------------------------------------- Terminal Mode config
tnoremap <C-k> <C-\><C-n>
if has('nvim')
  autocmd TermOpen * setlocal nonumber norelativenumber
  autocmd TermOpen * startinsert
endif
" Kinda nice when switching in the same tab, but not when switching tabs
"autocmd BufEnter term://* startinsert

" https://github.com/neovim/neovim/issues/3192
nnoremap <leader>gt :vs\|:te<cr>

tnoremap ˙ <C-\><C-n><C-w>h
tnoremap ∆ <C-\><C-n><C-w>j
tnoremap ˚ <C-\><C-n><C-w>k
tnoremap ¬ <C-\><C-n><C-w>l
tnoremap Ó <C-\><C-n><C-w>H
tnoremap Ô <C-\><C-n><C-w>J
" This is wrong but Shift-Alt-K doesn't seem to work? Uses I instead
tnoremap ˆ <C-\><C-n><C-w>K
tnoremap Ò <C-\><C-n><C-w>L

" ---------------------------------------- From Damian Conway
" https://github.com/ninrod/damian_conway_oscon_2013_tarball
" Color column 80th column
"highlight ColorColumn ctermbg=magenta
"call matchadd('ColorColumn', '\%81v', 100)

" EITHER the entire 81st column, full-screen...
highlight ColorColumn ctermbg=magenta
set colorcolumn=+1


" ---------------------------------------- Stuff I don't really understand

" When editing a file, always jump to the last cursor position
autocmd BufReadPost *
\ if ! exists("g:leave_my_cursor_position_alone") |
  \ if line("'\"") > 0 && line ("'\"") <= line("$") |
    \ exe "normal g'\"" |
  \ endif |
\ endif

" Comparing the file with what's saved on disk for conflicts
" From https://www.reddit.com/r/vim/comments/2rnraa/indicator_if_a_saved_file_has_changed/
" Press \d to diff buffer with saved file
" Not used:
" - https://vi.stackexchange.com/questions/1971/is-it-possible-to-have-the-output-of-a-command-in-a-split-rather-than-the-who
"   - creates a command RSplit with explicit commands
" - https://stackoverflow.com/questions/3619146/vimdiff-two-subroutines-in-same-file
"   - Diff two buffers
" - https://github.com/AndrewRadev/linediff.vim
"   - Specify two blocks to diff
function! s:DiffGitWithSaved()
  " Current file full path, see :help filename-modifiers
  let filename = expand('%:p')
  let diffname = tempname()
  execute 'silent w! '.diffname
  " Horizontal split (perhaps quickfix window is better?)
  new
  " No more "+" on the file name, won't ask for saving on exit
  setlocal buftype=nowrite
  " eval a string as vimscript, '0read' reads the following command, '!' runs
  " shell, git diff no index -- does a diff (not sure why git, doesn't need
  " it, then the two files, one is saved as a temporary file, then || true
  " makes the exit code 0 so that it doesn't print a weird thing
  execute '0read !git diff --no-index -- '.shellescape(filename).' '.diffname.' 2> /dev/null || true'
  setf diff
endfunction
com! DiffGitSaved call s:DiffGitWithSaved()
nmap <leader>dd :DiffGitSaved<CR>

